using System;
using System.Collections.Generic;
using System.Configuration;
using System.Data.Common;
using System.Data.SqlClient;
using System.Linq;
using System.Text;
using System.Threading.Tasks;






namespace HeirsPropertyDataLayer.Models
{
    class Donation
    {
        //give everything an organization ID of 0 no org //insert null
        public int IndividualID { get; set; }//Not Null //Do I need a get/set for this if these IDs are not being autogenerated but rather grabbed from previous autogen IDs
        public int OrganizationID { get; set; }//Null  //Same ? as above
        public int DonationType { get; set; }//Not Null  //Should this be an int or a string? In SQL it is under nvarchar, but should we make another table to store the various donation types and keep track of them through numbers?
        public decimal DonationAmount { get; set; }//Null  
        public string DonationDescription { get; set; }//Null  updat ppp for a person to enter a comment
        public DateTime DonationDate { get; set; }//Null  
        public int DonorStatus { get; set; }//Null  //A donor status table still needs to be made.....

        //Make add (insert) and select all (DONATION TABLE) functions
        public static Donation InsertDonation(Donation inDonation)//this has everything but the id
        {

            /////////////////This creates an event however due to autonumbering once its created we have to select to find out what its newid is IF we need it
            
            //There is no donation ID so this does not need to be retrieved (On PPP, Donor is selected from a combo box; This must be done (Not Null) to submit a donation)
            //This function allows a donation to be inputted and associates it with an individual and possibly company the individual is affiliated with
            //We need to figure out how to connnect the donation with the IndividualID and/or CompanyID

            /////////////////inserts event bc it doesn't have an id; the id needs to be returned so the user can use it later
            //Following the above logic, an invitee needs to be created before a donation is created otherwise there will not be an IndividualID to associate the donation with?


            Donation retDonation = inDonation;//this can't be changed as a parameter


            string constring = ConfigurationManager.ConnectionStrings[0].ConnectionString;
            SqlConnection myConnection = new SqlConnection(constring);
            string sqlstring = $"INSERT INTO  DonationTable  (DonationType, DonationAmount, DonationDescription, DonationDate, DonorStatus) VALUES({inDonation.DonationType},{inDonation.DonationAmount},{inDonation.DonationDescription},{inDonation.DonationDate},{inDonation.DonorStatus})";
            List<Donation> donations = new List<Donation>();//new list of object Donation created
            Donation myDonation = new Donation();//serves as a placeholder for each donation?


            try
            {
                //Event myretDonation = null;


                SqlClientFactory dbFactory = (SqlClientFactory)DbProviderFactories.GetFactory("Microsoft.Data.SqlClient");
                using (DbConnection dconnection = dbFactory.CreateConnection())
                {
                    if (dconnection != null)//sucessful
                    {
                        dconnection.ConnectionString = constring;
                        dconnection.Open();
                        DbCommand myCommand = dconnection.CreateCommand();
                        myCommand.CommandText = sqlstring;
                        int myresp = myCommand.ExecuteNonQuery();//My response executes a SQL statement
                        {
                           /* if (myresp > 0)
                            {
                                //xxxindividual id 
                                //use donor id 
                                retDonation.IndividualID = GetEventByName(inevent.EventName).EventID;//what the last donation added would have been
                                //retevent.EventID 
                                return retDonation;
                            }*/
                            //            string sqlstring = $"SELECT EventID,EventName,EventPrice,EventDate,EventDateDetermination,EventCapacity FROM EventTable WHERE EventName='{inName}'";
                        }
                        //create a unique select
                    }
                }
                return null;

            }
            catch (Exception ex)
            {

                //return false;
                throw ex;
                //return null;
            }

            //only worry about the above, if i have an autogenerated ID.
            //Donations are looked up by donation amount and donation

            //Takes in an event object and then updates the row on the table that has the same EventID



            //What should be done with Organization ID? Will this be figured out later for commercial release?
            //A person can donate on behalf of a company or however many people who belong to a company and donates will be tallied?


        }







        public static List<Event> SelectAll()//Haven't started making changes to the below
        {
            // returns  ALL events from the EventTable regardless of criteria
            string constring = ConfigurationManager.ConnectionStrings[0].ConnectionString;
            SqlConnection myConnection = new SqlConnection(constring);
            string sqlstring = "SELECT EventID,EventName,EventPrice,EventDate,EventDateDetermination,EventCapacity FROM EventTable ORDER BY EventID";
            List<Event> events = new List<Event>();//stores a list that stuff can be added to
            Event mySingleEvent = new Event();
            List<Event> myretEvents = null;//lets me know if there is nothing in a list



            try
            {
                //Event myretevent = null;

                SqlClientFactory dbFactory = (SqlClientFactory)DbProviderFactories.GetFactory("Microsoft.Data.SqlClient");//Turning regular database to a MicrosofSQLClient database (MS SQL Database); Casts SqlClientFactory and takes in "Microsoft.Data.SqlClient"
                using (DbConnection dconnection = dbFactory.CreateConnection())//createConection is a property from SQLClientFactory
                {
                    if (dconnection != null)//if I was able to make a database; Connection sucssessful
                    {
                        dconnection.ConnectionString = constring;//ConnectionString is a property
                        dconnection.Open();
                        DbCommand myCommand = dconnection.CreateCommand();
                        myCommand.CommandText = sqlstring;//The select command; sqlstring sets your query
                        using (DbDataReader myReader = myCommand.ExecuteReader())//make a new reader by executing a command
                        {
                            //            string sqlstring = $"SELECT EventID,EventName,EventPrice,EventDate,EventDateDetermination,EventCapacity FROM EventTable WHERE EventName='{inName}'";

                            while (myReader.Read())
                            {
                                mySingleEvent = new Event();
                                mySingleEvent.EventID = int.Parse(myReader["EventID"].ToString());
                                mySingleEvent.EventName = myReader["EventName"].ToString();
                                mySingleEvent.EventDate = DateTime.Parse(myReader["EventDate"].ToString());
                                mySingleEvent.EventPrice = Decimal.Parse(myReader["EventPrice"].ToString());
                                if (myReader.IsDBNull(5))//each row is coming through;IsDBNull at position 5 which corresponds to capacity set to -1
                                {
                                    mySingleEvent.EventCapacity = -1;
                                }
                                else
                                {
                                    mySingleEvent.EventCapacity = int.Parse(myReader["EventCapacity"].ToString());//it may not come back as an int, but rather a string
                                }
                                mySingleEvent.EventDateDetermination = int.Parse(myReader["EventDateDetermination"].ToString());//int parsing date determination and know it will come back as a #


                                events.Add(mySingleEvent);//add to list of events

                            }

                            if (events != null && events.Count > 0)
                            {

                                myretEvents = events;//sets retEvent = events so your list can be returned
                            }

                        }
                    }
                }



                return myretEvents;//if nothing is added returns to null

            }
            catch (Exception ex)
            {

                throw ex;
                //return null;
            }




        }


    }
}
